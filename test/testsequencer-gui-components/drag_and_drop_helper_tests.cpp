/******************************************************************************
 *
 * Project       : Graphical User Interface for SUP Sequencer
 *
 * Description   : Integrated development environment for Sequencer procedures
 *
 * Author        : Gennady Pospelov (IO)
 *
 * Copyright (c) : 2010-2024 ITER Organization,
 *                 CS 90 046
 *                 13067 St. Paul-lez-Durance Cedex
 *                 France
 *
 * This file is part of ITER CODAC software.
 * For the terms and conditions of redistribution or use of this software
 * refer to the file ITER-LICENSE.TXT located in the top level directory
 * of the distribution package.
 *****************************************************************************/

#include "sequencergui/viewmodel/instruction_editor_viewmodel.h"

#include <sequencergui/model/instruction_container_item.h>
#include <sequencergui/model/procedure_item.h>
#include <sequencergui/model/sequencer_model.h>
#include <sequencergui/model/standard_instruction_items.h>
#include <sequencergui/viewmodel/drag_and_drop_helper.h>
#include <sup/gui/components/mime_conversion_helper.h>

#include <mvvm/model/application_model.h>
#include <mvvm/model/validate_utils.h>
#include <mvvm/standarditems/container_item.h>

#include <gtest/gtest.h>

#include <QMimeData>

using namespace sequencergui;

//! Tests for helper methods from drag_and_drop_helper.h

class DragAndDropHelperTest : public ::testing::Test
{
public:
  DragAndDropHelperTest() : m_view_model(&m_model) {}

  mvvm::ApplicationModel m_model;
  InstructionEditorViewModel m_view_model;
};

TEST_F(DragAndDropHelperTest, GetIdentifiersToMove)
{
  const QMimeData mime_data;
  EXPECT_TRUE(GetIdentifiersToMove(&mime_data).empty());
  // more tests below
}

TEST_F(DragAndDropHelperTest, CreateInstructionMoveMimeData)
{
  auto sequence = m_model.InsertItem<SequenceItem>();

  auto sequence_displayname_index = m_view_model.index(0, 0);
  auto sequence_customname_index = m_view_model.index(0, 1);

  {  // row of two indexes as would be generated by tree view
    auto mime_data =
        CreateInstructionMoveMimeData({sequence_displayname_index, sequence_customname_index});

    EXPECT_TRUE(mime_data->hasFormat(kInstructionMoveMimeType));
    auto identifiers = GetIdentifiersToMove(mime_data.get());
    ASSERT_EQ(identifiers.size(), 1);
    EXPECT_EQ(identifiers.at(0), sequence->GetIdentifier());
  }

  {  // row of one index is not supported
    auto mime_data = CreateInstructionMoveMimeData({sequence_displayname_index});

    EXPECT_EQ(mime_data.get(), nullptr);
    EXPECT_TRUE(GetIdentifiersToMove(mime_data.get()).empty());
  }
}

TEST_F(DragAndDropHelperTest, GetNewInstructionType)
{
  const QMimeData mime_data;
  EXPECT_TRUE(GetNewInstructionType(&mime_data).empty());
  // more tests below
}

TEST_F(DragAndDropHelperTest, CreateNewInstructionMimeData)
{
  EXPECT_EQ(GetNewInstructionType(nullptr), std::string(""));

  auto mime_data = CreateNewInstructionMimeData("abc");
  EXPECT_EQ(GetNewInstructionType(mime_data.get()), std::string("abc"));

  mime_data = CreateNewInstructionMimeData("");
  EXPECT_EQ(GetNewInstructionType(mime_data.get()), std::string(""));
}

//! Validating helper method GetInternalMoveTagIndex.

TEST_F(DragAndDropHelperTest, GetInternalMoveTagIndex)
{
  auto sequence0 = m_model.InsertItem<SequenceItem>();
  auto wait0 = m_model.InsertItem<WaitItem>(sequence0);
  auto wait1 = m_model.InsertItem<WaitItem>(sequence0);
  auto wait2 = m_model.InsertItem<WaitItem>(sequence0);
  auto sequence1 = m_model.InsertItem<SequenceItem>();
  auto wait3 = m_model.InsertItem<WaitItem>(sequence1);

  // item is hovered on top of another item
  EXPECT_TRUE(GetInternalMoveTagIndex(*wait0, *sequence0, -1) == mvvm::TagIndex("", 0));

  // moving wait0, hover indicator shows space between wait0 and wait1
  // TagIndex should be shifted
  EXPECT_TRUE(GetInternalMoveTagIndex(*wait0, *sequence0, 1) == mvvm::TagIndex("", 0));

  // moving wait0, hover indicator shows space between wait1 and wait2
  // TagIndex should be shifted
  EXPECT_TRUE(GetInternalMoveTagIndex(*wait0, *sequence0, 2) == mvvm::TagIndex("", 1));

  // moving wait2, hover indicator shows space between wait0 and wait1
  // TagIndex the same as hover indicator
  EXPECT_TRUE(GetInternalMoveTagIndex(*wait1, *sequence0, 1) == mvvm::TagIndex("", 1));

  // moving wait0 to another parent
  // TagIndex the same as hover indicator
  EXPECT_TRUE(GetInternalMoveTagIndex(*wait0, *sequence1, 0) == mvvm::TagIndex("", 0));
  EXPECT_TRUE(GetInternalMoveTagIndex(*wait0, *sequence1, 1) == mvvm::TagIndex("", 1));
}

//! Validating helper method GetDropTagIndex.

TEST_F(DragAndDropHelperTest, GetDropTagIndex)
{
  // item is hovered on top of another item
  EXPECT_TRUE(GetDropTagIndex(-1) == mvvm::TagIndex("", 0));
  EXPECT_TRUE(GetDropTagIndex(42) == mvvm::TagIndex("", 42));
}

TEST_F(DragAndDropHelperTest, DropInstruction)
{
  SequencerModel model;
  auto procedure = model.InsertItem<ProcedureItem>(model.GetProcedureContainer());

  auto item = DropInstruction(domainconstants::kWaitInstructionType,
                              procedure->GetInstructionContainer(), mvvm::TagIndex::Append());

  EXPECT_EQ(item->GetType(), WaitItem::Type);
  EXPECT_EQ(item->GetDomainType(), domainconstants::kWaitInstructionType);
  EXPECT_EQ(procedure->GetInstructionContainer()->GetTotalItemCount(), 1);
}

//! Checking adding instruction aggregate.

TEST_F(DragAndDropHelperTest, DropAggregate)
{
  SequencerModel model;
  auto procedure = model.InsertItem<ProcedureItem>(model.GetProcedureContainer());

  auto item = dynamic_cast<UniversalInstructionItem*>(DropInstruction(
      "if-then-else", procedure->GetInstructionContainer(), mvvm::TagIndex::Append()));
  ASSERT_NE(item, nullptr);

  EXPECT_EQ(item->GetType(), UniversalInstructionItem::Type);
  EXPECT_EQ(item->GetDomainType(), domainconstants::kFallbackInstructionType);
}

TEST_F(DragAndDropHelperTest, CanInsertType)
{
  auto sequence = m_model.InsertItem<SequenceItem>();
  auto wait = m_model.InsertItem<WaitItem>(sequence);

  EXPECT_TRUE(mvvm::utils::CanInsertType(domainconstants::kWaitInstructionType, sequence,
                                         mvvm::TagIndex::Default(0))
                  .first);
  EXPECT_FALSE(mvvm::utils::CanInsertType(domainconstants::kWaitInstructionType, wait,
                                          mvvm::TagIndex::Default(0))
                   .first);
}

TEST_F(DragAndDropHelperTest, CreateInstructionFromMime)
{
  const QString mime_type = kCopyInstructionMimeType;

  const std::string expected_name("abc");
  WaitItem item;
  item.SetDisplayName(expected_name);

  auto data = sup::gui::CreateCopyMimeData(item, mime_type);
  EXPECT_TRUE(data->hasFormat(mime_type));

  auto reconstructed_item = sup::gui::CreateSessionItem(data.get(), mime_type);
  EXPECT_EQ(reconstructed_item->GetDisplayName(), expected_name);
  EXPECT_NE(dynamic_cast<WaitItem*>(reconstructed_item.get()), nullptr);
}
