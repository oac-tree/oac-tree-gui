/******************************************************************************
 *
 * Project       : Graphical User Interface for SUP Sequencer
 *
 * Description   : Integrated development environment for Sequencer procedures
 *
 * Author        : Gennady Pospelov (IO)
 *
 * Copyright (c) : 2010-2023 ITER Organization,
 *                 CS 90 046
 *                 13067 St. Paul-lez-Durance Cedex
 *                 France
 *
 * This file is part of ITER CODAC software.
 * For the terms and conditions of redistribution or use of this software
 * refer to the file ITER-LICENSE.TXT located in the top level directory
 * of the distribution package.
 *****************************************************************************/

#include "sequencergui/viewmodel/instruction_editor_viewmodel.h"

#include <sequencergui/model/standard_instruction_items.h>
#include <sequencergui/viewmodel/drag_and_drop_helper.h>

#include <mvvm/model/application_model.h>

#include <gtest/gtest.h>

#include <QMimeData>

using namespace sequencergui;

//! Tests for helper methods from drag_and_drop_helper.h

class DragAndDropHelperTestTest : public ::testing::Test
{
public:
  DragAndDropHelperTestTest() : m_view_model(&m_model) {}

  mvvm::ApplicationModel m_model;
  InstructionEditorViewModel m_view_model;
};

TEST_F(DragAndDropHelperTestTest, GetIdentifiersToMove)
{
  const QMimeData mime_data;
  EXPECT_TRUE(GetIdentifiersToMove(&mime_data).empty());
  // more tests below
}

TEST_F(DragAndDropHelperTestTest, CreateInstructionMoveMimeData)
{
  auto sequence = m_model.InsertItem<SequenceItem>();

  auto sequence_displayname_index = m_view_model.index(0, 0);
  auto sequence_customname_index = m_view_model.index(0, 1);

  {  // row of two indexes as would be generated by tree view
    auto mime_data =
        CreateInstructionMoveMimeData({sequence_displayname_index, sequence_customname_index});

    EXPECT_TRUE(mime_data->hasFormat(kInstructionMoveMimeType));
    auto identifiers = GetIdentifiersToMove(mime_data.get());
    ASSERT_EQ(identifiers.size(), 1);
    EXPECT_EQ(identifiers.at(0), sequence->GetIdentifier());
  }

  {  // row of one index is not supported
    auto mime_data = CreateInstructionMoveMimeData({sequence_displayname_index});

    EXPECT_EQ(mime_data.get(), nullptr);
    EXPECT_TRUE(GetIdentifiersToMove(mime_data.get()).empty());
  }
}

TEST_F(DragAndDropHelperTestTest, GetNewInstructionType)
{
  const QMimeData mime_data;
  EXPECT_TRUE(GetNewInstructionType(&mime_data).empty());
  // more tests below
}

TEST_F(DragAndDropHelperTestTest, CreateNewInstructionMimeData)
{
  EXPECT_EQ(GetNewInstructionType(nullptr), std::string(""));

  auto mime_data = CreateNewInstructionMimeData("abc");
  EXPECT_EQ(GetNewInstructionType(mime_data.get()), std::string("abc"));

  mime_data = CreateNewInstructionMimeData("");
  EXPECT_EQ(GetNewInstructionType(mime_data.get()), std::string(""));
}

//! Validating helper method GetInternalMoveTagIndex.

TEST_F(DragAndDropHelperTestTest, GetInternalMoveTagIndex)
{
  auto sequence0 = m_model.InsertItem<SequenceItem>();
  auto wait0 = m_model.InsertItem<WaitItem>(sequence0);
  auto wait1 = m_model.InsertItem<WaitItem>(sequence0);
  auto wait2 = m_model.InsertItem<WaitItem>(sequence0);
  auto sequence1 = m_model.InsertItem<SequenceItem>();
  auto wait3 = m_model.InsertItem<WaitItem>(sequence1);

  // item is hovered on top of another item
  EXPECT_TRUE(GetInternalMoveTagIndex(*wait0, *sequence0, -1) == mvvm::TagIndex("", 0));

  // moving wait0, hover indicator shows space between wait0 and wait1
  // TagIndex should be shifted
  EXPECT_TRUE(GetInternalMoveTagIndex(*wait0, *sequence0, 1) == mvvm::TagIndex("", 0));

  // moving wait0, hover indicator shows space between wait1 and wait2
  // TagIndex should be shifted
  EXPECT_TRUE(GetInternalMoveTagIndex(*wait0, *sequence0, 2) == mvvm::TagIndex("", 1));

  // moving wait2, hover indicator shows space between wait0 and wait1
  // TagIndex the same as hover indicator
  EXPECT_TRUE(GetInternalMoveTagIndex(*wait1, *sequence0, 1) == mvvm::TagIndex("", 1));

  // moving wait0 to another parent
  // TagIndex the same as hover indicator
  EXPECT_TRUE(GetInternalMoveTagIndex(*wait0, *sequence1, 0) == mvvm::TagIndex("", 0));
  EXPECT_TRUE(GetInternalMoveTagIndex(*wait0, *sequence1, 1) == mvvm::TagIndex("", 1));
}

//! Validating helper method GetDropTagIndex.

TEST_F(DragAndDropHelperTestTest, GetDropTagIndex)
{
  // item is hovered on top of another item
  EXPECT_TRUE(GetDropTagIndex(-1) == mvvm::TagIndex("", 0));
  EXPECT_TRUE(GetDropTagIndex(42) == mvvm::TagIndex("", 42));
}
